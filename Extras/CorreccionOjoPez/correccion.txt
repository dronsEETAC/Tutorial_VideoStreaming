
Puedes corregir la distorsi칩n con cv2.undistort() en OpenCV, pero necesitas calibrar la c치mara primero para obtener sus par치metros intr칤nsecos y de distorsi칩n.

游닝 Paso 1: Calibrar la c치mara
Captura un conjunto de im치genes (10-20) de un patr칩n de calibraci칩n (generalmente un tablero de ajedrez) desde distintos 치ngulos y posiciones. Luego usa el siguiente script de calibraci칩n:


import cv2
import numpy as np
import glob

# Tama침o del patr칩n (n칰mero de esquinas internas)
pattern_size = (9, 6)
objp = np.zeros((pattern_size[0]*pattern_size[1],3), np.float32)
objp[:,:2] = np.mgrid[0:pattern_size[0], 0:pattern_size[1]].T.reshape(-1,2)

objpoints = []
imgpoints = []

images = glob.glob('calib_images/*.jpg')

for fname in images:
    img = cv2.imread(fname)
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    ret, corners = cv2.findChessboardCorners(gray, pattern_size, None)
    if ret:
        objpoints.append(objp)
        imgpoints.append(corners)

ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::-1], None, None)

# Guarda los par치metros
np.savez('camera_calib.npz', mtx=mtx, dist=dist)


游닝 Paso 2: Corregir distorsi칩n
Una vez tengas los par치metros mtx (matriz intr칤nseca) y dist (coeficientes de distorsi칩n):



import cv2
import numpy as np

data = np.load('camera_calib.npz')
mtx, dist = data['mtx'], data['dist']

img = cv2.imread('imagen_gran_angular.jpg')
h, w = img.shape[:2]
newcameramtx, roi = cv2.getOptimalNewCameraMatrix(mtx, dist, (w,h), 1, (w,h))

undistorted = cv2.undistort(img, mtx, dist, None, newcameramtx)

cv2.imwrite('undistorted.jpg', undistorted)

